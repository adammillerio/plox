#!/usr/bin/env python3
from collections import deque
from enum import IntEnum, auto
from typing import Dict, Iterable

from lox.expr import (
    Assign,
    Binary,
    Call,
    Expr,
    Get,
    Grouping,
    Literal,
    Logical,
    Set,
    Super,
    This,
    Unary,
    Variable,
)
from lox.expr import Visitor as ExprVisitor
from lox.interpreter import Interpreter
from lox.lox import Lox
from lox.stmt import (
    Block,
    Class,
    Expression,
    Function,
    If,
    Print,
    Return,
    Stmt,
    Var,
    While,
)
from lox.stmt import Visitor as StmtVisitor
from lox.token import Token


class FunctionType(IntEnum):
    """Currently resolving function type, used for error handling."""

    # Top-level code
    NONE = auto()
    # Function definition
    FUNCTION = auto()
    # Initializer (constructor method on a class)
    INITIALIZER = auto()
    # Method, which is a function defined on a class and bound to it's
    # instances
    METHOD = auto()


class ClassType(IntEnum):
    """Currently resolving class type, used for error handling."""

    # Top-level code
    NONE = auto()
    # Class definition
    CLASS = auto()
    # Subclass definition
    SUBCLASS = auto()


class Resolver(ExprVisitor[None], StmtVisitor[None]):
    """Lox Resolver

    State and scoping in Lox is implemented via a linked list of Environments. To
    facilitate faster variable lookups in enclosing scopes, this Resolver process
    is ran against the statements generated by the Parser in order to create a
    mapping of expressions to their "depth" in the Environment tree. This mapping
    is populated as the "locals" value on the Interpreter via the resolve() method.

    For example:
    source = \"\"\"
    fun fib(n) {
      if (n <= 1) return n;
      return fib(n - 2) + fib(n - 1);
    }

    for (var i = 0; i < 20; i = i + 1) {
      print fib(i);
    }
    \"\"\"
    tokens = Scanner(source).scan_tokens()
    statements = Parser(tokens).parse()
    interpreter = Interpreter()
    resolver = Resolver(interpreter)
    resolver.resolve(statements)
    print(interpreter.locals)

    Results in the in interpreter.locals containing:
    {
        Variable(Token(TokenType.IDENTIFIER, "n", None, 2): 0,
        Variable(Token(TokenType.IDENTIFIER, "n", None, 2): 0,
        Variable(Token(TokenType.IDENTIFIER, "n", None, 3): 0,
        Variable(Token(TokenType.IDENTIFIER, "n", None, 3): 0,
        Variable(Token(TokenType.IDENTIFIER, "i", None, 6): 0,
        Variable(Token(TokenType.IDENTIFIER, "i", None, 7): 2,
        Variable(Token(TokenType.IDENTIFIER, "i", None, 6): 1,
        Assign(
            name=Token(TokenType.IDENTIFIER, "i", None, 6),
            value=Binary(
                left=Variable(TokenType.IDENTIFIER, "i", None, 6),
                operator=Token(TokenType.PLUS, "+", None, 6),
                right=Literal(1.0),
            ),
        ): 1,
    }

    During execution, the Interpreter uses this to look up the depth within the
    scope tree that a given expression is located. See the method
    Interpreter.look_up_variable for more info.

    Unlike the Interpreter, the Resolver walks the entirety of the AST, ignoring
    control flow. The scope stack is implemented via a double-ended queue, mostly
    analagous to the Java Stack class, which holds all variable declarations in
    each scope along with their current state (Initialized/Not Initialized). As
    the Resolver enters and exits scopes, it will add and remove these scopes
    from the queue.

    When an expression is encountered that requires local resolution (Variable,
    Super, and This), the resolve_local() function will be called. This function
    walks backwards through the scope tree until it finds one which contains
    the correct variable. If found, it then calls resolve() on the interpreter
    to store the resolved "depth".

    The Resolver also handles some error handling scenarios, such as undefined
    variables, or using this/super expressions in places like the global scope
    or a class without a superclass.

    Args:
        interpreter: Interpreter. Interpreter to resolve statements for. All
            variables will be resolved using the resolve() method on this instance.

    Public Attributes:
        scopes: deque[Dict[str, bool]. Scope queue for variable resolution.
        current_function: FunctionType. The type of the current function being
            resolved, if any. This is used for error detection, such as top
            level return statements.
        current_class: ClassType. The type of the current class being resolved,
            if any. This is used for error detection, such as using super in
            a non-subclass.
    """

    def __init__(self, interpreter: Interpreter) -> None:
        self.interpreter = interpreter
        self.scopes: deque[Dict[str, bool]] = deque()
        self.current_function: FunctionType = FunctionType.NONE
        self.current_class: ClassType = ClassType.NONE

    def resolve(self, statements: Iterable[Stmt]) -> None:
        """Resolve statements.

        This is the entrypoint to the Resolver process, which will traverse the
        statements provided and resolve all variable scope information in the
        Interpreter.

        Args:
            statements: Iterable[Stmt]. Statements to resolve, typically from a
                source read by the Parser.
        """

        for statement in statements:
            self.resolve_stmt(statement)

    def resolve_stmt(self, stmt: Stmt) -> None:
        """Resolve a statement.

        This will fully traverse this statement, visiting all expressions
        regardless of control flow, in order to enumerate all defined variables
        and their scopes.

        All variables will be added to self.interpreter.locals via resolve()

        Args:
            stmt: Stmt. Statement to resolve.
        """

        stmt.accept(self)

    def resolve_expr(self, expr: Expr) -> None:
        """Resolve an expression.

        This will resolve a single expression within a statement that is being
        traversed by the Resolver.

        Args:
            expr: Expr. Expression to resolve.
        """

        expr.accept(self)

    def resolve_function(self, function: Function, type: FunctionType) -> None:
        """Resolve a function statement.

        This walks through a function, creating a scope for the function
        and any arguments it may have. It then resolves all statements in the
        function body.

        Args:
            function: Function. Function statement to resolve.
            type: FunctionType. Type of function being resolved, used for error
                handling ie returning a value from a class initializer.
        """

        # Store the previous value, since functions can be defined in functions
        enclosing_function = self.current_function
        # Set the new current function type
        self.current_function = type

        # Create a new local scope for the function call
        self.begin_scope()

        for param in function.params:
            # Declare and define all function parameters, so that they are
            # available during function body resolution
            self.declare(param)
            self.define(param)

        self.resolve(function.body)
        self.end_scope()

        # Restore previous function type
        self.current_function = enclosing_function

    def begin_scope(self) -> None:
        """Enter into a new scope, creating a new dictionary on the stack."""

        self.scopes.append({})

    def end_scope(self) -> None:
        """Exit a scope, removing the dictionary from the stack.

        Any referenced variables at this scope have been resolved in the interpreter,
        so the reference is no longer needed.
        """

        self.scopes.pop()

    def declare(self, name: Token) -> None:
        """Declare a variable in the current scope.

        Given a name, this will declare it in the current scope's variable
        dictionary. The value will be set to False, indicating that the variable
        has not been defined yet (assigned a value). If an expression references
        this variable before it is defined, a runtime error will be raised.

        Args:
            name: Token. Name representing the variable to declare.
        """

        if not self.scopes:
            # Global (top-level) scope, not tracked in locals/Resolver
            return

        scope = self.scopes[-1]

        # Error on variable redefinition outside of the global scope
        # var a = "first"
        # var a = "second"; <- Error
        if name.lexeme in scope:
            Lox.error(name, "Already a variable with this name in this scope.")

        # Place the var in the scope on tbe top of the stack, with a false to
        # indicate that it is not initialized yet. This prevents it from being
        # referenced prior to initialization.
        # var a = "outer";
        # { var a = a; } <- Error, a is in scope but still false
        scope[name.lexeme] = False

    def define(self, name: Token) -> None:
        """Define a variable in the current scope.

        Given a name this will look up the variable declaration from declare()
        in the current scope and set it to True, indicating that it has a value
        assigned to it and is ready for use.

        When an expression which requires this variable is encountered in this
        scope, or any below it (assuming it is not shadowed), the amount of
        steps up the scope tree will be recorded in the interpreter's locals.

        Args:
            name: Token. Name representing the variable to define.
        """

        if not self.scopes:
            return

        # Mark the var as initialized, so that it can be used
        self.scopes[-1][name.lexeme] = True

    def resolve_local(self, expr: Expr, name: Token) -> None:
        """Resolve a local variable in an expression.

        This method is called whenever an expression is encountered which requires
        local variable resolution (Variable/Super/This).

        It will locate the correct scope in the scope tree which contains a
        defined variable corresponding to the given expression. This value


        Args:
            expr: Expr. Expression which requires variable resolution.
            name: Token. Token representing the name or keyword which requires
                resolution.
        """

        # Traverse backwards through the scope stack
        for i in range(len(self.scopes) - 1, -1, -1):
            # This scope has a variable with this name
            if name.lexeme in self.scopes[i]:
                # Resolve the variable corresponding to this expression with
                # the number of scopes backward that it is located
                self.interpreter.resolve(expr, len(self.scopes) - 1 - i)
                return

    def visit_block_stmt(self, stmt: Block) -> None:
        """Resolve a block statement.

        Blocks represent arbitrary scopes, so this just creates one and resolves
        all the statements within it.

        Args:
            stmt: Block. Block statement to resolve.
        """

        self.begin_scope()
        self.resolve(stmt.statements)
        self.end_scope()

    def visit_class_stmt(self, stmt: Class) -> None:
        """Resolve a class statement.

        This defines a new class, creating a new scope, registering this/super
        references as necessary, and resolves all methods.

        Args:
            stmt: Class. Class statement to resolve.
        """

        # Store the previous value, since classes can be defined in classes
        enclosing_class = self.current_class
        # Set the new current class type
        self.current_class = ClassType.CLASS

        self.declare(stmt.name)
        self.define(stmt.name)

        # class Foo < Foo {} <- Error
        if (
            stmt.superclass is not None
            and stmt.name.lexeme == stmt.superclass.name.lexeme
        ):
            Lox.error(stmt.superclass.name, "A class can't inherit from itself.")

        # Resolve the superclass variable if there is one
        if stmt.superclass is not None:
            # Now resolving a subclass
            self.current_class = ClassType.SUBCLASS
            self.resolve_expr(stmt.superclass)

        # Create a new scope and place the "super" variable in it, so that
        # it will be available in the subclass
        if stmt.superclass is not None:
            self.begin_scope()
            self.scopes[-1]["super"] = True

        # Create a new enclosing scope for this method definition
        self.begin_scope()
        # Register "this" as a variable, to be used in class methods
        self.scopes[-1]["this"] = True

        for method in stmt.methods:
            declaration = FunctionType.METHOD

            if method.name.lexeme == "init":
                declaration = FunctionType.INITIALIZER

            self.resolve_function(method, declaration)

        # Discard the scope with "this"
        self.end_scope()

        # Discard the scope with "super" if there is a superclass
        if stmt.superclass is not None:
            self.end_scope()

        # Restore previous value
        self.current_class = enclosing_class

    def visit_expression_stmt(self, stmt: Expression) -> None:
        """Resolve an expression statement.

        This just resolves the inner expression.

        Args:
            stmt: Expression. Expression statement to resolve.
        """

        # Resolve a single expression statement
        self.resolve_expr(stmt.expression)

    def visit_function_stmt(self, stmt: Function) -> None:
        """Resolve a function statement.

        This defines the function itself in the enclosing scope, then resolves
        the function itself via resolve_function().

        Args:
            stmt: Function. Function statement to resolve.
        """

        # Declare and define the function itself in the enclosing scope, this
        # is done eagerly before resolving the body, in order to allow the
        # function body to refer to itself during recursion
        self.declare(stmt.name)
        self.define(stmt.name)

        self.resolve_function(stmt, FunctionType.FUNCTION)

    def visit_if_stmt(self, stmt: If) -> None:
        """Resolve an if statement.

        This resolves the condition expression as well as both the then and
        else branch (if defined), regardless of control flow.

        Args:
            stmt: If. If statement to resolve.
        """

        # Resolve if condition and then branch, there is no control flow here,
        # so all paths are traversed during resolution
        self.resolve_expr(stmt.condition)
        self.resolve_stmt(stmt.then_branch)

        if stmt.else_branch is not None:
            # Resolve else branch if it exists
            self.resolve_stmt(stmt.else_branch)

    def visit_print_stmt(self, stmt: Print) -> None:
        """Resolve a print statement.

        This resolves the inner expression that is being printed.

        Args:
            stmt: Print. Print statement to resolve.
        """

        self.resolve_expr(stmt.expression)

    def visit_return_stmt(self, stmt: Return) -> None:
        """Resolve a return statement.

        This checks if the return is in a valid context, and resolves the inner
        expression if it is.

        Args:
            stmt: Return. Return statement to resolve.
        """

        # Not in any function, can't return
        if self.current_function is FunctionType.NONE:
            Lox.error(stmt.keyword, "Can't return from top-level code.")

        # Resolve expression being returned, if present
        if stmt.value is not None:
            # Constructor/initializer methods always return this implicitly,
            # so any return with a value in one is an error
            if self.current_function is FunctionType.INITIALIZER:
                Lox.error(stmt.keyword, "Can't return a value from an initializer.")

            # Redundant check for type checker
            assert stmt.value is not None
            self.resolve_expr(stmt.value)

    def visit_var_stmt(self, stmt: Var) -> None:
        """Visit a var statement.

        This declares, initializes, and defines the variable in the current
        scope, so that it can be resolved later.

        Args:
            stmt: Var. Var statement to resolve.
        """

        self.declare(stmt.name)

        if stmt.initializer is not None:
            self.resolve_expr(stmt.initializer)

        self.define(stmt.name)

    def visit_while_stmt(self, stmt: While) -> None:
        """Resolve a while statement.

        This resolves the condition and the body a single time.

        Args:
            stmt: While. While statement to resolve.
        """

        # Resolve the condition and body, no control flow, so the loop is
        # always evaluated once
        self.resolve_expr(stmt.condition)
        self.resolve_stmt(stmt.body)

    def visit_assign_expr(self, expr: Assign) -> None:
        """Resolve an assignment expression.

        This will resolve the local variable being assigned and record the depth
        in the interpreter.

        Args:
            expr: Assign. Assignment expression to resolve.
        """

        # Resolve the expression to be assigned for references to other vars
        # ie var a = i + 1
        self.resolve_expr(expr.value)
        # Resolve the variable that is being assigned to
        self.resolve_local(expr, expr.name)

    def visit_binary_expr(self, expr: Binary) -> None:
        """Resolve a binary expression.

        This resolves both operands of the binary expression.

        Args:
            expr: Binary. Binary expression to evaluate.
        """

        self.resolve_expr(expr.left)
        self.resolve_expr(expr.right)

    def visit_call_expr(self, expr: Call) -> None:
        """Resolve a call expression.

        This resolves the callee itself and any arguments to the call.

        Args:
            expr: Call. Call expression to evaluate.
        """

        # Resolve the callee itself
        self.resolve_expr(expr.callee)

        for argument in expr.arguments:
            # Resolve all arguments to the call
            self.resolve_expr(argument)

    def visit_get_expr(self, expr: Get) -> None:
        """Resolve a get expression.

        This resolves the left side of a property access/get expression. The
        right side (property dispatch) happens at runtime in the interpreter
        through LoxInstance.get()

        Args:
            expr: Get. Get expression to resolve.
        """

        # Resolve the left side of a property access/get expression
        # The right side (property dispatch) happens at runtime in the
        # interpreter
        self.resolve_expr(expr.object)

    def visit_grouping_expr(self, expr: Grouping) -> None:
        """Resolve a grouping expression.

        This resolves the inner expression inside the parenthesis.

        Args:
            expr: Grouping. Grouping expression to resolve.
        """

        self.resolve_expr(expr.expression)

    def visit_literal_expr(self, expr: Literal) -> None:
        """Resolve a literal expression.

        This is a no-op as no resolution is necessary for Literals. Their values
        are eagerly parsed and stored directly in the Token itself.

        Args:
            expr: Literal. Literal expression to resolve.
        """

        pass

    def visit_logical_expr(self, expr: Logical) -> None:
        """Resolve a logical expression.

        This resolves both sides of the expression without short circuiting.

        Args:
            expr: Logical. Logical expression to resolve.
        """

        self.resolve_expr(expr.left)
        self.resolve_expr(expr.right)

    def visit_set_expr(self, expr: Set) -> None:
        """Resolve a set expression.

        Args:
            expr: Set. Set expression to resolve.
        """

        self.resolve_expr(expr.value)
        self.resolve_expr(expr.object)

    def visit_super_expr(self, expr: Super) -> None:
        """Resolve a super expression.

        This checks to see if super is being used in a valid context and resolves
        the location of the super definition in the scope created by the Class
        statement itself.

        Args:
            expr: Super. Super expression to resolve.
        """

        if self.current_class is ClassType.NONE:
            # super.NotInClass() <- Error
            Lox.error(expr.keyword, "Can't use 'super' outside of a class.")
        elif self.current_class is not ClassType.SUBCLASS:
            # class Foo { method() { print super.method() } } <- Error
            Lox.error(expr.keyword, "Can't use 'super' in a class with no superclass.")

        self.resolve_local(expr, expr.keyword)

    def visit_this_expr(self, expr: This) -> None:
        """Resolve a this expression.

        This checks to see if this is being used in a valid context and resolves
        the location of the this definition in the scope created by the Class
        statement itself.

        Args:
            expr: This. This expression to resolve.
        """

        if self.current_class is ClassType.NONE:
            # this keyword used outside of class scope, error
            Lox.error(expr.keyword, "Can't use 'this' outside of a class.")
            return

        self.resolve_local(expr, expr.keyword)

    def visit_unary_expr(self, expr: Unary) -> None:
        """Resolve a unary expression.

        This resolves the operand to the unary expression itself.

        Args:
            expr: Unary. Unary expression to resolve.
        """

        self.resolve_expr(expr.right)

    def visit_variable_expr(self, expr: Variable) -> None:
        """Resolve a variable expression.

        This will resolve the location of the variable in the scope tree and
        store it in the interpreter's locals collection.

        Args:
            expr: Variable. Variable expression to resolve.
        """

        # Variable is declared but not initialized yet
        # var a = a + 1; <- Error
        # Ruff doesn't like the direct comparison to False but get returns None
        # when unset, which is also falsey
        if self.scopes and self.scopes[-1].get(expr.name.lexeme) == False:  # noqa: E712
            Lox.error(expr.name, "Can't read local variable in its own initializer.")

        self.resolve_local(expr, expr.name)
